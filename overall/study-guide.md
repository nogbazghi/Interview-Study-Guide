#Study Guide Topics


These will be discussed:

1. Sorting Algorithms
  * Bubble Sort
  * Selection Sort
  * Insertion Sort
  * Mergesort
  * Quicksort
  * Intro Sort
  * Tim Sort
  * Radix Sort Distribution Based|
  * Bucket Sort [Distribution Based]
  * Shell Sort
  * Topological Sort
2. Data Structures
  * Singly Linked List
  * Doubly Linked List
  * Circular Linked List
  * Queue
  * Stack
  * Deque
  * Hash Table
  * Hash Map
  * Hash Set
  * Set (Interface)
  * Map (Interface)
  * Binary Tree
  * Binary Search Tree
  * Red-Black Tree
  * AVL Tree
  * Spanning Tree
  * Graphs (Undirected, Weighted Acyclic, Tree, Forest)
  * Flow Network (aka directed graph)
  * Priority Queue
  * Trie
  * Suffix Tree
2.  General Alogirthms
  * Binary Search
  * Knuth–Morris–Pratt Algorithm
  * Robin-Karp Alogirthm
  * Dijkstra's Algorithm
  * A*
  * Depth First Search
  * Breadth First Search
  * Minimum Spanning Tree
  * MST Prim's
  * MST Kruskal's
  * Chu-Li Edmond's (Directed Graphs)
  * LRU cache
  * Knapsack [Dynamic]
  * Fibonacci [Dynamic]
  * Towers of Hanoi [Dynamic]
  * Longest Common Subsequence [Dynamic]
  * Ford-Fulkerson Algorithm
  * Min-Max Theorem (Network Flow)
  * Simplex (Network Flow)
  * Binary Heap
  * Blossom algorithm (Graph)
4. Common Interview Problems
  * Palindromes
  * Most/Least common character
  * Longest Alphabetized Substring
  * Word Ladder
  * Linked-List/Graph Traversal (Sum)
  * Backtracking
  * DFS/BFS


<ul>
<li>O(1) < O(log(n)) < O(n) < O(n*log(n)) < O(n<sup>2</sup>) < O(2<sup>n</sup>) < O(n!)</li>
</ul>

<table>
<thread>
  <tr>
    <th>Sorting Algorithm</th>
    <th>Best Case</th><th>Worst Case</th><th>Avg Case [If applicable]</th><th>Space Complexity</th>
  </tr>
 </thread><tbody>
<tr><th>Bubble Sort</th>
  <td>O(n)</td><td>O(n<sup>2</sup>)</td><td></td><td> </td>
</tr>
<!---->
<tr><th>Selection Sort</th>
  <td>O(n<sup>2</sup>) </td><td> O(n<sup>2</sup>) </td><td> </td><td> </td>
</tr>
  <!---->
<tr><th>Insertion Sort</th>
  <td>O(n)</td><td>O(n<sup>2</sup>)</td><td></td><td> </td>
  </tr>
<!---->
<tr><th>Merge Sort</th>
  <td>O(n*log(n))</td><td>O(n*log(n))</td><td></td><td> </td>
</tr>
  <!---->
<tr><th>Quick Sort</th>
   <td>O(n*log(n))</td><td>O(n<sup>2</sup>)</td><td></td><td> </td>
</tr>
<!---->
<tr><th>Intro Sort</th>
     <td>O(n*log(n))</td><td>O(n*log(n))</td><td></td><td> </td>
</tr>
<tr><th>Tim Sort</th>
  <td>O(n)</td><td>O(n*log(n))</td><td></td><td> </td>
</tr>
  <!---->
<tr><th>Radix Sort [Distribution Based]</th>
<td></td><td></td><td></td><td> </td>
</tr>
  <!---->
<tr><th>Bucket Sort [Distribution Based]</th>
<td></td><td></td><td></td><td> </td>
</tr>
  <!---->
<tr> <th>Shell Sort</th>
<td></td><td></td><td></td><td> </td>
</tr>
  <!---->
<tr> <th>Topological Sort</th>
<td></td><td></td><td></td><td> </td>
</tr>
  <!---->
 </tbody></table>





<table>
<thread>
  <tr>
    <th>Sorting Algorithm Explained</th>
    <th> When to use? </th><th>Explain Runtime & Space Complexity</th>
  </tr>
 </thread><tbody>

<tr><th>Bubble Sort</th>
  <td> X</td> <td>X </td>
</tr>
<!---->
<tr><th>Selection Sort</th>
  <td> X</td> <td>X </td>
</tr>
<!---->
<tr><th>Insertion Sort</th>
  <td> X</td> <td>X </td>
</tr>
<!---->
<tr><th>Merge Sort</th>
  <td> You require a consistent runtime  </td>
  <td>X </td>
</tr>
<!---->
<tr><th>Quick Sort</th>
  <td> Stable runtime isn't required. You may randomize your pivot selection in order to get more </td>
  <td>X </td>
</tr>
<!---->
<tr><th>Intro Sort</th>
  <td> X</td> <td>X </td>
</tr>
<!---->
<tr><th>Tim Sort</th>
  <td> X</td> <td>X </td>
</tr>
<!---->
<tr><th>Radix Sort [Distribution Based]</th>
  <td> X</td> <td>X </td>
</tr>
<!---->
<tr><th>Bucket Sort [Distribution Based]</th>
  <td> X</td> <td>X </td>
</tr>
<!---->
<tr><th>Shell Sort</th>
  <td> X</td> <td>X </td>
</tr>
<!---->
<tr><th>Topological Sort </th>
  <td> X</td> <td>X </td>
</tr>
<!---->
</tbody></table>





<table>
<thread>
  <tr>
    <th>Data Structure</th>
    <th> Methods  </th> <th>Runtimes </th> <th> Java Code </th>
  </tr>
 </thread><tbody>

<tr><th>Singly Linked List</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Doubly Linked List </th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Circular Linked List</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Queue</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Stack</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Deque</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Hash Table</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Hash Map</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Hash Set</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Set</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Map</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Binary Tree</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Binary Search Tree</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Priority Queue</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Red-Black Tree</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>AVL Tree</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th> Spanning Tree</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Graphs (Undirected, Weighted Acyclic, Tree, Forest)</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Flow Network (aka directed graph)</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Trie</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Suffix Tree</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
<!---->
<tr><th>Heap</th>
  <td> X</td> <td>X </td>  <td>X </td>
</tr>
 </tbody></table>





<table>
<thread>
  <tr>
    <th>Data Structure Specifics</th>
    <th>Explain</th>
  </tr>
 </thread><tbody>

<tr><th>Singly Linked List</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Doubly Linked List </th>
  <td> X</td>
</tr>
<!---->
<tr><th>Circular Linked List</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Queue</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Stack</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Deque</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Hash Table</th>
  <td> Synchronized, allows duplcates, doesn't allow nulls, (K,V) </td>
</tr>
<!---->
<tr><th>Hash Map</th>
  <td> No duplicates, not synchronized, order is not maintained, not thread safe, allows null</td>
</tr>
<!---->
<tr><th>Hash Set</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Set</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Map</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Binary Tree</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Binary Search Tree</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Priority Queue</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Red-Black Tree</th>
  <td> X</td>
</tr>
<!---->
<tr><th>AVL Tree</th>
  <td> X</td>
</tr>
<!---->
<tr><th> Spanning Tree</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Graphs (Undirected, Weighted Acyclic, Tree, Forest)</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Flow Network (aka directed graph)</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Trie</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Suffix Tree</th>
  <td> X</td>
</tr>
<!---->
<tr><th>Heap</th>
  <td> X</td>
</tr>
 </tbody></table>





